<!DOCTYPE html>
<!--
TODO
* Out-of-band POST if settings changed too quickly
* Immidiately notify if all touches ended
* Make it working on firefox: touchend d3.touches returns
different results on chromium and firefox.
 -->

<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Devastator Mission Control Centre</title>

    <!-- JQUERY -->
    <script src="//ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>

    <!-- BOOTSTRAP -->
    <!-- Latest compiled and minified CSS -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css">
    <!-- Optional theme -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap-theme.min.css">
    <!-- Latest compiled and minified JavaScript -->
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/js/bootstrap.min.js"></script>

    <script src="http://ajax.googleapis.com/ajax/libs/swfobject/2.2/swfobject.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.3/d3.min.js"></script>
    <script type="text/javascript">
      var parameters = { src: "rtmp://" + window.location.hostname + "/rtmp/live" };

      swfobject.embedSWF
      ( "/static/StrobeMediaPlayback.swf"
      , "strobeMediaPlayback"
      , 640
      , 480
      , "10.1.0"
      , {}
      , parameters
      , { allowFullScreen: "true"}
      , { name: "strobeMediaPlayback" }
      );
    </script>
    <style>
.circle {
  /*fill: green;*/
  /*fill-opacity: 0.5;*/
  stroke: black;
  stroke-width: 4;
  /*stroke-opacity: 0.6;*/
}

#controls {
  width: 640px;
  height: 480px;
  border: solid black 1px;
  background-color: red;
}

#logWindow {
  border:solid black 1px;
  background-color: gray;
  height: 15em;
  width: 20em;
  overflow: scroll;
  overflow-x: hidden;
}
    </style>
    <script>
        "use strict";

        var log = {
          info: function(msg) {
            d3.select("#logWindow")
            .insert("div", "*")
            .text(msg);
          }
        }

        function Joystick(svg, id, color) {
          this.svg = svg;
          this.id = id;
          this.color = color;
          this.pos = undefined;
          this.center = undefined;
          this.circle = undefined;
          this.pointer = undefined;
          this.diameter = 100;
          this.timerEvent = undefined;
          this.updateFreq = 5;  // in Hz
          this.value = [0.0, 0.0];
          this.canSend = undefined;
        }

        Joystick.prototype.constructor = Joystick;
        Joystick.prototype.constructor.prototype.toString = function() {
          return "Joystick";
        }


        Joystick.prototype.start = function(pos) {
          this.stop();  // reset everything;
          this.pos = pos;
          this.canSend = true;
          this.center = this.svg.append("circle")
            .attr("cx", pos[0])
            .attr("cy", pos[1])
            .attr("r", 2)
          ;

          this.circle = this.svg.append("circle")
            .attr("class", "circle")
            .attr("cx", pos[0])
            .attr("cy", pos[1])
            .attr("r", this.diameter)
            .style("fill", this.color)
          ;

          this.pointer = this.svg.append("circle")
            .attr("cx", pos[0])
            .attr("cy", pos[1])
            .attr("r", 40)
          ;


          // var joystick = this
          // this.svg.on("mousemove", function() {
          //   joystick.move(d3.mouse(this))
          // });

          // this.timerEvent = setInterval(this.onTimer.bind(this),
          //                               1.0/this.updateFreq*1000);
        }


        // TODO: rename to sendUpdate
        Joystick.prototype.onTimer = function() {
          if (!this.canSend) {
            log.info("previous message not ACKed, throttling timer")
            return;
          }
          log.info("timer fired");
          this.canSend = false;
          var joystick = this
          var data = JSON.stringify(joystick.value)
          log.info("sending " + data)
          d3.xhr("/cam/set")
            .header("Content-Type", "application/json")
            .post(data, function(err, resp) {
              if (err) {
                log.info("request error: " + err.status + " " + err.statusText);
                joystick.stop()
                return
              }
              joystick.canSend = true;
              log.info("got control response: " + resp);
            });
        }


        Joystick.prototype.move = function(pos) {
          var dx = pos[0] - this.pos[0];
          var dy = pos[1] - this.pos[1];
          var r = Math.sqrt(dx*dx + dy*dy);
          if (r > this.diameter) {
            var factor = r / this.diameter;
            dx = dx / factor;
            dy = dy / factor;
          }

          // '-' because we invert Y axis
          this.value = [dx/this.diameter, -dy/this.diameter];

          this.pointer
            .attr("cx", this.pos[0] + dx)
            .attr("cy", this.pos[1] + dy)
          ;
        }


        Joystick.prototype.stop = function() {
          // timer stuff
          this.canSend = false;
          clearInterval(this.timerEvent);

          // TODO: put widgets into separate hierarchy?
          if (this.center) { this.center.remove(); }
          if (this.circle) { this.circle.remove(); }
          if (this.pointer)  { this.pointer.remove();  }

          this.pos = undefined;
          this.value = [0.0, 0.0];
        }



        $(function() {
          log.info("started!");
          var svg = d3.select("#controls");
          var svgwidth = parseInt(svg.style("width"));

          var mousestick;
          var sticks = {
            move: new Joystick(svg, "move", "green"),
            look: new Joystick(svg, "look", "white")
          }
          var stickmap = d3.map()

          function apply(meth) {
            d3.event.preventDefault();
            d3.touches(this).forEach(function(touch) {
              // log.info("action:" + meth + " " + touch.identifier);
              stickmap.get(touch.identifier)[meth](touch);
            })
          }

          function selectstick(pos) {
            var stick;
            if (pos[0] < svgwidth / 2) {
              stick = sticks.move;
            } else {
              stick = sticks.look;
            }
            return stick;
          }

          svg
            .on("mousedown", function() {
              d3.event.preventDefault();
              var pos = d3.mouse(this);
              mousestick = selectstick(pos);
              mousestick.start(pos);
            })
            .on("mousemove", function() {
              if (mousestick) {
                mousestick.move(d3.mouse(this));
              }
            })

            .on("mouseup", function() {
              if (mousestick) {
                mousestick.stop();
                mousestick = undefined;
              }
            })
            // TODO: duplicate methods
            .on("mouseleave", function() {
              if (mousestick) {
                log.info("mouse leave");
                mousestick.stop();
                mousestick = undefined;
              }
            })

            .on("touchstart", function() {
              d3.event.preventDefault();
              d3.touches(this).forEach(function(touch) {
                var stick;
                if (touch[0] < svgwidth / 2) {
                  stick = sticks.move;
                } else {
                  stick = sticks.look;
                }
                stick.start(touch);
                stickmap.set(touch.identifier, stick);
              })
            })
            .on("touchmove", function() {
              apply.apply(this, ["move"]);
            })
            .on("touchcancel", function() {
              apply.apply(this, ["stop"]);
            })
            .on("touchleave", function() {
              apply.apply(this, ["stop"]);
            })
            .on("touchend", function() {
              d3.event.preventDefault();
              var active = [];
              log.info("touch() " + d3.touch(this))
              d3.touches(this).forEach(function(touch) {
                active.push(touch.identifier);
              });
              stickmap.forEach(function(key, value) {
                if (active.indexOf(parseInt(key)) == -1) {
                  value.stop();
                  stickmap.remove(key);
                }
              });
              if (stickmap.empty()) {
                log.info("no touches left");
              }
            })
          ;
        })
    </script>
  </head>

  <body>
<!--
    <div class="page-header">
      <h1>Devastator 2.0 <small>Exterminate! Exterminate!</small></h1>
    </div>
    <button id="CamReset" type="button" class="btn btn-default">
      Reset cam position
    </button>
    <div id="strobeMediaPlayback">
      <p>Here supposed to be a video player. Flash blocked or not supported?</p>
    </div>
    <br>
 -->
    <svg id="controls"></svg>
    <br>
   <div id="logWindow"></div>
  </body>
</html>
